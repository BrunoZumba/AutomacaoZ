sudo nano /etc/default/keyboard
	XKBMODEL="abnt2"
	XKBLAYOUT="br"
	XKBVARIANT=""
	XKBOPTIONS="lv3?:alt_switch,compose:rctrl"

sudo apt-get install codeblocks
sudo apt-get install subversion
sudo apt-get update
sudo apt-get install xsltproc

wget https://ufpr.dl.sourceforge.net/project/lirc/LIRC/0.9.4d/lirc-0.9.4d.tar.bz2
tar jxf lirc-0.9.4d.tar.bz2 
./configure
make
sudo make install

sudo apt-get install lirc

Coloca no final /etc/modules
	lirc_dev
	lirc_rpi gpio_in_pin=23 gpio_out_pin=22

NÃO FIZ ISSO NA VM
Coloca /etc/lirc/hardware.conf
	LIRCD_ARGS="--uinput"
	DRIVER="default"
	DEVICE="/dev/lirc0"
	MODULES="lirc_rpi"

NÃO FIZ ISSO NA VM
Coloca no /boot/config.txt
	dtoverlay=lirc-rpi,gpio_in_pin=23,gpio_out_pin=22


Adiciona arquivo de configuração dos controles em /etc/lirc/lircd.conf

***** Para testar *******

# Via linha de comando:
irsend -d /var/run/lirc/lircd SEND_ONCE ControleNet KEY_ENTER

# Via programa C

#include "lirc_client.h"

int main(int argc, char** argv)
{
    int fd;

    fd = lirc_get_local_socket("/var/run/lirc/lircd", 0);
    if (fd < 0) {
        // Process error
    }
    if (lirc_send_one(fd, "ControleNet", "KEY_ENTER") == -1) {
        // Process errors
    };
}


gcc -o main /usr/local/lib/liblirc_client.so main.cpp
./main










#include <wiringPi.h>

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#define MAXTIMINGS      85
#define DHTPIN          7
int dht11_dat[5] = { 0, 0, 0, 0, 0 };

void read_dht11_dat()
{
        uint8_t laststate       = HIGH;
        uint8_t counter         = 0;
        uint8_t j               = 0, i;
        float   f; /* fahrenheit */

        dht11_dat[0] = dht11_dat[1] = dht11_dat[2] = dht11_dat[3] = dht11_dat[4] = 0;

        /* pull pin down for 18 milliseconds */
        pinMode( DHTPIN, OUTPUT );
        digitalWrite( DHTPIN, LOW );
        delay( 18 );
        /* then pull it up for 40 microseconds */
        digitalWrite( DHTPIN, HIGH );
        delayMicroseconds( 40 );
        /* prepare to read the pin */
        pinMode( DHTPIN, INPUT );

        /* detect change and read data */
        for ( i = 0; i < MAXTIMINGS; i++ )
        {
                counter = 0;
                while ( digitalRead( DHTPIN ) == laststate )
                {
                        counter++;
                        delayMicroseconds( 1 );
                        if ( counter == 255 )
                        {
                                break;
                        }
                }
                laststate = digitalRead( DHTPIN );

                if ( counter == 255 )
                        break;

                /* ignore first 3 transitions */
                if ( (i >= 4) && (i % 2 == 0) )
                {
                        /* shove each bit into the storage bytes */
                        dht11_dat[j / 8] <<= 1;
                        if ( counter > 16 )
                                dht11_dat[j / 8] |= 1;
                        j++;
                }
        }

        /*
         * check we read 40 bits (8bit x 5 ) + verify checksum in the last byte
         * print it out if data is good
         */
        if ( (j >= 40) &&
             (dht11_dat[4] == ( (dht11_dat[0] + dht11_dat[1] + dht11_dat[2] + dht11_dat[3]) & 0xFF) ) )
        {
                f = dht11_dat[2] * 9. / 5. + 32;
                printf( "Humidity = %d.%d %% Temperature = %d.%d *C (%.1f *F)\n",
                        dht11_dat[0], dht11_dat[1], dht11_dat[2], dht11_dat[3], f );
        }else  {
                printf( "Data not good, skip\n" );
        }
}




